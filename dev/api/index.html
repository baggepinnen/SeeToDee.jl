<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SeeToDee Documentation</title><meta name="title" content="API · SeeToDee Documentation"/><meta property="og:title" content="API · SeeToDee Documentation"/><meta property="twitter:title" content="API · SeeToDee Documentation"/><meta name="description" content="Documentation for SeeToDee Documentation."/><meta property="og:description" content="Documentation for SeeToDee Documentation."/><meta property="twitter:description" content="Documentation for SeeToDee Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SeeToDee Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/SeeToDee.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/SeeToDee.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#SeeToDee.AdaptiveStep"><code>SeeToDee.AdaptiveStep</code></a></li><li><a href="#SeeToDee.BackwardEuler"><code>SeeToDee.BackwardEuler</code></a></li><li><a href="#SeeToDee.ForwardEuler"><code>SeeToDee.ForwardEuler</code></a></li><li><a href="#SeeToDee.Heun"><code>SeeToDee.Heun</code></a></li><li><a href="#SeeToDee.RKC2"><code>SeeToDee.RKC2</code></a></li><li><a href="#SeeToDee.Rk3"><code>SeeToDee.Rk3</code></a></li><li><a href="#SeeToDee.Rk4"><code>SeeToDee.Rk4</code></a></li><li><a href="#SeeToDee.SimpleColloc"><code>SeeToDee.SimpleColloc</code></a></li><li><a href="#SeeToDee.SuperSampler"><code>SeeToDee.SuperSampler</code></a></li><li><a href="#SeeToDee.SwitchingIntegrator"><code>SeeToDee.SwitchingIntegrator</code></a></li><li><a href="#SeeToDee.Trapezoidal"><code>SeeToDee.Trapezoidal</code></a></li><li><a href="#SeeToDee.initialize"><code>SeeToDee.initialize</code></a></li><li><a href="#SeeToDee.linearize"><code>SeeToDee.linearize</code></a></li></ul><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><h3 id="Integrators"><a class="docs-heading-anchor" href="#Integrators">Integrators</a><a id="Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SeeToDee.ForwardEuler"><a class="docstring-binding" href="#SeeToDee.ForwardEuler"><code>SeeToDee.ForwardEuler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">f_discrete = ForwardEuler(f, Ts; supersample = 1)</code></pre><p>Discretize a continuous-time dynamics function <code>f</code> using forward Euler with sample time <code>Tₛ</code>.  <code>f</code> is assumed to have the signature <code>f : (x,u,p,t)-&gt;ẋ</code> and the returned function <code>f_discrete : (x,u,p,t)-&gt;x(t+Tₛ)</code>.</p><p><code>supersample</code> determines the number of internal steps, this can be increased to make the integration more accurate, but it might be favorable to choose a higher-order method instead. <code>u</code> is assumed constant during all steps.</p><p>If called with StaticArrays, this integrator is allocation free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L350-L359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.Heun"><a class="docstring-binding" href="#SeeToDee.Heun"><code>SeeToDee.Heun</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">f_discrete = Heun(f, Ts; supersample = 1)</code></pre><p>Discretize a continuous-time dynamics function <code>f</code> using Heun&#39;s method with sample time <code>Tₛ</code>. <code>f</code> is assumed to have the signature <code>f : (x,u,p,t)-&gt;ẋ</code> and the returned function <code>f_discrete : (x,u,p,t)-&gt;x(t+Tₛ)</code>.</p><p><code>supersample</code> determines the number of internal steps, this can be increased to make the integration more accurate, but it might be favorable to choose a higher-order method instead. <code>u</code> is assumed constant during all steps.</p><p>If called with StaticArrays, this integrator is allocation free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L396-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.Rk3"><a class="docstring-binding" href="#SeeToDee.Rk3"><code>SeeToDee.Rk3</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">f_discrete = Rk3(f, Ts; supersample = 1)</code></pre><p>Discretize a continuous-time dynamics function <code>f</code> using RK3 with sample time <code>Tₛ</code>. <code>f</code> is assumed to have the signature <code>f : (x,u,p,t)-&gt;ẋ</code> and the returned function <code>f_discrete : (x,u,p,t)-&gt;x(t+Tₛ)</code>.</p><p><code>supersample</code> determines the number of internal steps, 1 is often sufficient, but this can be increased to make the integration more accurate. <code>u</code> is assumed constant during all steps.</p><p>If called with StaticArrays, this integrator is allocation free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L301-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.Rk4"><a class="docstring-binding" href="#SeeToDee.Rk4"><code>SeeToDee.Rk4</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">f_discrete = Rk4(f, Ts; supersample = 1)</code></pre><p>Discretize a continuous-time dynamics function <code>f</code> using RK4 with sample time <code>Tₛ</code>.  <code>f</code> is assumed to have the signature <code>f : (x,u,p,t)-&gt;ẋ</code> and the returned function <code>f_discrete : (x,u,p,t)-&gt;x(t+Tₛ)</code>.</p><p><code>supersample</code> determines the number of internal steps, 1 is often sufficient, but this can be increased to make the integration more accurate. <code>u</code> is assumed constant during all steps.</p><p>If called with StaticArrays, this integrator is allocation free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L221-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.RKC2"><a class="docstring-binding" href="#SeeToDee.RKC2"><code>SeeToDee.RKC2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">f_discrete = RKC2(f, Ts; supersample=1, stages=nothing, L_est=nothing, eta=0.05)</code></pre><p>Discretize a continuous-time dynamics function <code>f</code> using a second-order stabilized explicit Runge–Kutta–Chebyshev (RKC2) method with sample time <code>Tₛ</code>.</p><ul><li><code>f</code> must have the signature <code>f(x, u, p, t) -&gt; ẋ</code>.</li><li>The returned callable <code>f_discrete(x,u,p,t; Ts=Ts_override)</code> advances one step to <code>x(t+Tₛ)</code>.</li><li><code>supersample</code> = number of internal substeps per call (keeps <code>u</code> constant inside the step).</li><li><code>stages</code> = number of Chebyshev stages <code>m</code>. If not provided, it is chosen from <code>L_est</code>.</li><li><code>L_est</code> = estimate of the spectral radius of the Jacobian (or diffusion operator) over the step; if given (and <code>stages</code> not given), we pick <code>m</code> large enough so the step is stable.</li><li><code>eta</code> = damping parameter in (0,1); 0.05–0.1 are common. Larger <code>eta</code> slightly shortens the stability interval but improves internal stability.</li></ul><p><strong>Notes</strong></p><p>• This is an <em>explicit stabilized</em> method: very effective when stiffness is mostly dissipative   (eigenvalues with large negative real parts, e.g., diffusion/semi-discrete parabolic PDEs).   It is <em>not</em> a general cure for oscillatory stiffness (strong imaginary spectrum).</p><p>• If called with <code>StaticArrays</code>, the method is allocation free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L942-L964">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.SimpleColloc"><a class="docstring-binding" href="#SeeToDee.SimpleColloc"><code>SeeToDee.SimpleColloc</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimpleColloc(dyn, Ts, nx, na, nu; n = 5, abstol = 1.0e-8, solver=SimpleNewtonRaphson(), residual=false)
SimpleColloc(dyn, Ts, x_inds, a_inds, nu; n = 5, abstol = 1.0e-8, solver=SimpleNewtonRaphson(), residual=false)</code></pre><p>A simple direct-collocation integrator that can be stepped manually, similar to the function returned by <a href="#SeeToDee.Rk4"><code>SeeToDee.Rk4</code></a>.</p><p>This integrator supports differential-algebraic equations (DAE), the dynamics is expected to be on either of the forms </p><ul><li><code>nx,na</code> provided: <code>(xz,u,p,t)-&gt;[ẋ; res]</code> where <code>xz</code> is a vector <code>[x; z]</code> contaning the differential state <code>x</code> and the algebraic variables <code>z</code> in this order. <code>res</code> is the algebraic residuals, and <code>u</code> is the control input. The algebraic residuals are thus assumed to be the last <code>na</code> elements of of the arrays returned by the dynamics (the convention used by ModelingToolkit).</li><li><code>x_inds, a_inds</code> provided: <code>(xz,u,p,t)-&gt;xzd</code> where <code>xzd[x_inds] = ẋ</code> and <code>xzd[a_inds] = res</code>.</li></ul><p>The returned function has the signature <code>f_discrete : (x,u,p,t)-&gt;x(t+Tₛ)</code>. </p><p>This integrator also supports a fully implicit form of the dynamics</p><p class="math-container">\[0 = F(ẋ, x, u, p, t)\]</p><p>When using this interface, the dynamics is called using an additional input <code>ẋ</code> as the first argument, and the return value is expected to be the residual of the entire state descriptor. To use the implicit form, pass <code>residual = true</code>.</p><p>A Gauss-Radau collocation method is used to discretize the dynamics. The resulting nonlinear problem is solved using (by default) a Newton-Raphson method. This method handles stiff dynamics.</p><p><strong>Arguments:</strong></p><ul><li><code>dyn</code>: Dynamics function (continuous time)</li><li><code>Ts</code>: Sample time</li><li><code>nx</code>: Number of differential state variables</li><li><code>na</code>: Number of algebraic variables</li><li><code>x_inds, a_inds</code>: If indices are provided instead of <code>nx</code> and <code>na</code>, the mass matrix is assumed to be diagonal, with ones located at <code>x_inds</code> and zeros at <code>a_inds</code>. For maximum efficiency, provide these indices as unit ranges or static arrays.</li><li><code>nu</code>: Number of inputs</li><li><code>n</code>: Number of collocation points. <code>n=2</code> corresponds to trapezoidal integration.</li><li><code>abstol</code>: Tolerance for the root finding algorithm</li><li><code>residual</code>: If <code>true</code> the dynamics function is assumed to return the residual of the entire state descriptor and have the signature <code>(ẋ, x, u, p, t) -&gt; res</code>. This is sometimes called &quot;fully implicit form&quot;.</li><li><code>solver</code>: Any compatible SciML Nonlinear solver to use for the root finding problem</li><li><code>scale_x</code>: If provided, the state variables are scaled by this vector before being passed to the nonlinear solver. This can improve convergence for states with very different magnitudes. The scaling is applied as <code>res .= res ./ scale_x</code> before being passed to the solver.</li></ul><p><strong>Extended help</strong></p><ul><li>Super-sampling is not supported by this integrator, see <a href="#SeeToDee.SuperSampler"><code>SeeToDee.SuperSampler</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L491-L528">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.Trapezoidal"><a class="docstring-binding" href="#SeeToDee.Trapezoidal"><code>SeeToDee.Trapezoidal</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Trapezoidal(dyn, Ts, nx, na, nu; abstol = 1.0e-8, solver=SimpleNewtonRaphson(), residual=false)
Trapezoidal(dyn, Ts, x_inds, a_inds, nu; abstol = 1.0e-8, solver=SimpleNewtonRaphson(), residual=false)</code></pre><p>A simple trapezoidal integrator that can be stepped manually, similar to the function returned by <a href="#SeeToDee.Rk4"><code>SeeToDee.Rk4</code></a>.</p><p>This integrator supports differential-algebraic equations (DAE), the dynamics is expected to be on either of the forms </p><ul><li><code>nx,na</code> provided: <code>(xz,u,p,t)-&gt;[ẋ; res]</code> where <code>xz</code> is a vector <code>[x; z]</code> contaning the differential state <code>x</code> and the algebraic variables <code>z</code> in this order. <code>res</code> is the algebraic residuals, and <code>u</code> is the control input. The algebraic residuals are thus assumed to be the last <code>na</code> elements of of the arrays returned by the dynamics (the convention used by ModelingToolkit).</li><li><code>x_inds, a_inds</code> provided: <code>(xz,u,p,t)-&gt;xzd</code> where <code>xzd[x_inds] = ẋ</code> and <code>xzd[a_inds] = res</code>.</li></ul><p>The returned function has the signature <code>f_discrete : (x,u,p,t)-&gt;x(t+Tₛ)</code>. </p><p><strong>Arguments:</strong></p><ul><li><code>dyn</code>: Dynamics function (continuous time)</li><li><code>Ts</code>: Sample time</li><li><code>nx</code>: Number of differential state variables</li><li><code>na</code>: Number of algebraic variables</li><li><code>x_inds, a_inds</code>: If indices are provided instead of <code>nx</code> and <code>na</code>, the mass matrix is assumed to be diagonal, with ones located at <code>x_inds</code> and zeros at <code>a_inds</code>. For maximum efficiency, provide these indices as unit ranges or static arrays.</li><li><code>nu</code>: Number of inputs</li><li><code>abstol</code>: Tolerance for the root finding algorithm</li><li><code>residual</code>: If <code>true</code> the dynamics function is assumed to return the residual of the entire state descriptor and have the signature <code>(ẋ, x, u, p, t) -&gt; res</code>. This is sometimes called &quot;fully implicit form&quot;.</li><li><code>solver</code>: Any compatible SciML Nonlinear solver to use for the root finding problem</li><li><code>scale_x</code>: If provided, the residual is scaled by this vector before being passed to the nonlinear solver, <code>res ./ scale_x</code>. This can help with convergence if the state variables have very different magnitudes.</li></ul><p><strong>Extended help</strong></p><ul><li>Super-sampling is not supported by this integrator, see <a href="#SeeToDee.SuperSampler"><code>SeeToDee.SuperSampler</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L673-L699">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.BackwardEuler"><a class="docstring-binding" href="#SeeToDee.BackwardEuler"><code>SeeToDee.BackwardEuler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BackwardEuler(dyn, Ts, nx, na, nu; abstol = 1.0e-8, solver=SimpleNewtonRaphson(), residual=false)
BackwardEuler(dyn, Ts, x_inds, a_inds, nu; abstol = 1.0e-8, solver=SimpleNewtonRaphson(), residual=false)</code></pre><p>A simple backward Euler integrator that can be stepped manually.</p><p>This integrator supports differential-algebraic equations (DAE), the dynamics is expected to be on either of the forms</p><ul><li><code>nx,na</code> provided: <code>(xz,u,p,t)-&gt;[ẋ; res]</code> where <code>xz</code> is a vector <code>[x; z]</code> contaning the differential state <code>x</code> and the algebraic variables <code>z</code> in this order. <code>res</code> is the algebraic residuals, and <code>u</code> is the control input. The algebraic residuals are thus assumed to be the last <code>na</code> elements of of the arrays returned by the dynamics (the convention used by ModelingToolkit).</li><li><code>x_inds, a_inds</code> provided: <code>(xz,u,p,t)-&gt;xzd</code> where <code>xzd[x_inds] = ẋ</code> and <code>xzd[a_inds] = res</code>.</li></ul><p>The returned function has the signature <code>f_discrete : (x,u,p,t)-&gt;x(t+Tₛ)</code>.</p><p>This integrator also supports a fully implicit form of the dynamics</p><p class="math-container">\[0 = F(ẋ, x, u, p, t)\]</p><p>When using this interface, the dynamics is called using an additional input <code>ẋ</code> as the first argument, and the return value is expected to be the residual of the entire state descriptor. To use the implicit form, pass <code>residual = true</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>dyn</code>: Dynamics function (continuous time)</li><li><code>Ts</code>: Sample time</li><li><code>nx</code>: Number of differential state variables</li><li><code>na</code>: Number of algebraic variables</li><li><code>x_inds, a_inds</code>: If indices are provided instead of <code>nx</code> and <code>na</code>, the mass matrix is assumed to be diagonal, with ones located at <code>x_inds</code> and zeros at <code>a_inds</code>. For maximum efficiency, provide these indices as unit ranges or static arrays.</li><li><code>nu</code>: Number of inputs</li><li><code>abstol</code>: Tolerance for the root finding algorithm</li><li><code>residual</code>: If <code>true</code> the dynamics function is assumed to return the residual of the entire state descriptor and have the signature <code>(ẋ, x, u, p, t) -&gt; res</code>. This is sometimes called &quot;fully implicit form&quot;.</li><li><code>solver</code>: Any compatible SciML Nonlinear solver to use for the root finding problem</li><li><code>scale_x</code>: If provided, the residual is scaled by this vector before being passed to the nonlinear solver, <code>res ./ scale_x</code>. This can help with convergence if the state variables have very different magnitudes.</li></ul><p><strong>Notes</strong></p><p>The backward Euler method is a first-order implicit method that is unconditionally stable (A-stable), making it suitable for stiff problems. The method solves:</p><p class="math-container">\[x(t+Tₛ) = x(t) + Tₛ \cdot f(x(t+Tₛ), u, p, t+Tₛ)\]</p><p>This requires solving a nonlinear system at each step, but provides better stability properties than explicit methods like ForwardEuler, especially for stiff dynamics. It is simpler and cheaper per iteration than Trapezoidal (only one dynamics evaluation per solve vs. two), but is only first-order accurate compared to Trapezoidal&#39;s second-order accuracy.</p><p><strong>Extended help</strong></p><ul><li>Super-sampling is not supported by this integrator, see <a href="#SeeToDee.SuperSampler"><code>SeeToDee.SuperSampler</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L805-L844">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.AdaptiveStep"><a class="docstring-binding" href="#SeeToDee.AdaptiveStep"><code>SeeToDee.AdaptiveStep</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AdaptiveStep(integrator)</code></pre><p>A wrapper that enables automatic step subdivision for taking arbitrary-length steps with any integrator.</p><p>When the requested step size <code>Ts</code> is larger than the integrator&#39;s effective step size (<code>largest_Ts</code>),  <code>AdaptiveStep</code> automatically subdivides the step using the integrator&#39;s internal supersample mechanism  (for explicit integrators) or manual stepping (for implicit integrators).</p><p><strong>Fields</strong></p><ul><li><code>integ</code>: The wrapped integrator</li><li><code>largest_Ts</code>: The largest step size the integrator can take in a single call (<code>Ts / supersample</code>)</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs"># Wrap any integrator to enable automatic step subdivision
base_integrator = Rk4(dynamics, 0.1; supersample=2)  # largest_Ts = 0.05
adaptive_integrator = AdaptiveStep(base_integrator)

# Take arbitrary step sizes - automatically subdivides when needed
x_next = adaptive_integrator(x, u, p, t; Ts=0.3)  # Uses supersample=6 internally</code></pre><p><strong>Notes</strong></p><ul><li>This wrapper does NOT use error control - it only ensures step sizes never exceed <code>largest_Ts</code></li><li>For explicit integrators (<code>Rk4</code>, <code>Rk3</code>, <code>ForwardEuler</code>, <code>Heun</code>), uses built-in supersample mechanism</li><li>For implicit integrators (<code>SimpleColloc</code>, <code>Trapezoidal</code>), performs manual step subdivision</li><li>When <code>Ts ≤ largest_Ts</code>, calls the integrator directly without subdivision</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SeeToDee, StaticArrays

# Define dynamics
function simple_dynamics(x, u, p, t)
    return -x + u
end

# Create base integrator with supersample=3
base = SeeToDee.Rk4(simple_dynamics, 0.1; supersample=3)  # largest_Ts = 0.1/3 ≈ 0.033

# Wrap with AdaptiveStep
adaptive = SeeToDee.AdaptiveStep(base)

x0 = SA[1.0]
u = SA[0.5]

# Small step - no subdivision needed
x1 = adaptive(x0, u, 0, 0; Ts=0.02)  # Direct call

# Large step - automatic subdivision
x2 = adaptive(x0, u, 0, 0; Ts=0.5)   # Uses supersample=15 internally</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L30-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.SuperSampler"><a class="docstring-binding" href="#SeeToDee.SuperSampler"><code>SeeToDee.SuperSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SuperSampler(integ, supersample)</code></pre><p>A wrapper that enables supersampling for any integrator by manually stepping multiple times.</p><p>When an integrator doesn&#39;t have built-in <code>supersample</code> support (like <code>Trapezoidal</code>, <code>BackwardEuler</code>, or <code>SimpleColloc</code>), this wrapper allows you to take <code>supersample</code> internal steps to produce one effective step of duration <code>Ts</code>.</p><p><strong>Fields</strong></p><ul><li><code>integ</code>: The wrapped integrator</li><li><code>supersample</code>: Number of internal steps to take per call</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs"># Wrap an implicit integrator to add supersampling
base_integrator = Trapezoidal(dynamics, 0.1, 4, 0, 1)
supersampled = SuperSampler(base_integrator, 5)  # Takes 5 steps of 0.02s each

# Each call advances by Ts=0.1 using 5 internal steps
x_next = supersampled(x, u, p, t)  # Equivalent to 5 steps of 0.02s</code></pre><p><strong>Notes</strong></p><ul><li>The input <code>u</code> is held constant during all internal steps</li><li>Each internal step uses time <code>Ts / supersample</code></li><li>Time <code>t</code> is advanced appropriately for each internal step</li><li>All args and kwargs are forwarded to the wrapped integrator</li><li>Type-stable when used with StaticArrays</li></ul><p><strong>Comparison with AdaptiveStep</strong></p><ul><li><code>AdaptiveStep</code>: Handles arbitrary step sizes by automatic subdivision (for variable Ts)</li><li><code>SuperSampler</code>: Fixed supersampling for improved accuracy (for constant Ts with more substeps)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SeeToDee, StaticArrays

# Define dynamics
function dynamics(x, u, p, t)
    return -x + u
end

# Create implicit integrator without supersample support
base = Trapezoidal(dynamics, 0.1, 1, 0, 1)

# Add supersampling for better accuracy
supersampled = SuperSampler(base, 10)  # 10 internal steps

x0 = SA[1.0]
u = SA[0.5]

# Single step with 10 internal substeps
x1 = supersampled(x0, u, 0, 0.0)

# Can also override Ts at call time (if integrator supports it)
x2 = supersampled(x0, u, 0, 0.0; Ts=0.05)  # Uses 10 steps of 0.005s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L116-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.SwitchingIntegrator"><a class="docstring-binding" href="#SeeToDee.SwitchingIntegrator"><code>SeeToDee.SwitchingIntegrator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SwitchingIntegrator(int_true, int_false, cond)</code></pre><p>Create an integrator that switches between two different integrators based on a condition.</p><ul><li><code>int_true</code>: Integrator to use when <code>cond(...)</code> is true</li><li><code>int_false</code>: Integrator to use when <code>cond(...)</code> is false</li><li><code>cond(x,u,p,t,args...)</code>: A function that takes the same arguments as the integrator and returns a <code>Bool</code></li></ul><p>This can be used to, e.g., use a faster integrator when the state is in a certain region and a more accurate (but slower) integrator otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L195-L204">source</a></section></details></article><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SeeToDee.linearize"><a class="docstring-binding" href="#SeeToDee.linearize"><code>SeeToDee.linearize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">A,B = linearize(f, x0, u0, p, t)</code></pre><p>Linearize dynamics function <code>f(x, u, p, t)</code> w.r.t., state <code>x</code>, input <code>u</code>. Returns Jacobians <code>A,B</code> in</p><p class="math-container">\[ẋ = A\, Δx + B\, Δu\]</p><p>Works for both continuous and discrete-time dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L11-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SeeToDee.initialize"><a class="docstring-binding" href="#SeeToDee.initialize"><code>SeeToDee.initialize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize(integ, x0, u, p, t = 0.0; solver=integ.solver, abstol=integ.abstol)</code></pre><p>Given the differential state variables in <code>x0</code>, initialize the algebraic variables by solving the nonlinear problem <code>f(x,u,p,t) = 0</code> using the provided solver.</p><p><strong>Arguments:</strong></p><ul><li><code>integ</code>: An intergrator like <a href="#SeeToDee.SimpleColloc"><code>SeeToDee.SimpleColloc</code></a></li><li><code>x0</code>: Initial state descriptor (differential and algebraic variables, where the algebraic variables comes last)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SeeToDee.jl/blob/02bae680ce9d3f16d5603328e9a90e0977637c4b/src/SeeToDee.jl#L627-L635">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Monday 23 February 2026 10:21">Monday 23 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
