var documenterSearchIndex = {"docs":
[{"location":"api/#Exported-functions-and-types","page":"API","title":"Exported functions and types","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Docstrings","page":"API","title":"Docstrings","text":"","category":"section"},{"location":"api/#Integrators","page":"API","title":"Integrators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SeeToDee.Rk4\nSeeToDee.SimpleColloc","category":"page"},{"location":"api/#SeeToDee.Rk4","page":"API","title":"SeeToDee.Rk4","text":"f_discrete = Rk4(f, Ts; supersample = 1)\n\nDiscretize a continuous-time dynamics function f using RK4 with sample time Tₛ.  f is assumed to have the signature f : (x,u,p,t)->ẋ and the returned function f_discrete : (x,u,p,t)->x(t+Tₛ).\n\nsupersample determins the number of internal steps, 1 is often sufficient, but this can be increased to make the interation more accurate. u is assumed constant during all steps.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeeToDee.SimpleColloc","page":"API","title":"SeeToDee.SimpleColloc","text":"SimpleColloc(dyn, Ts, nx, na, nu; n = 5, abstol = 1.0e-8, solver=NewtonRaphson(), residual=false)\n\nA simple direct-collocation integrator that can be stepped manually, similar to the function returned by Rk4.\n\nThis integrator supports differential-algebraic equations (DAE), the dynamics is expected to be on the form (xz,u,p,t)->[ẋ; res] where xz is a vector [x; z] contaning the differential state x and the algebraic variables z in this order. res is the algebraic residuals, and u is the control input. The algebraic residuals are thus assumed to be the last na elements of of the arrays returned by the dynamics (the convention used by ModelingToolkit). The returned function has the signature f_discrete : (x,u,p,t)->x(t+Tₛ). \n\nThis integrator also supports a fully implicit form of the dynamics\n\n0 = F(x x u p t)\n\nWhen using this interface, the dynamics is called using an additional input ẋ as the first argument, and the return value is expected to be the residual of the entire state descriptor.\n\nA Gauss-Lobatto collocation method is used to discretize the dynamics. The resulting nonlinear problem is solved using (by default) a Newton-Raphson method. This method handles stiff dynamics.\n\nArguments:\n\ndyn: Dynamics function (continuous time)\nTs: Sample time\nnx: Number of differential state variables\nna: Number of algebraic variables\nnu: Number of inputs\nn: Number of collocation points. n=2 corresponds to trapezoidal integration.\nabstol: Tolerance for the root finding algorithm\nresidual: If true the dynamics function is assumed to return the residual of the entire state descriptor and have the signature (ẋ, x, u, p, t) -> res. This is sometimes called \"fully implicit form\".\nsolver: Any compatible SciML Nonlinear solver to use for the root finding problem\n\n\n\n\n\n","category":"type"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SeeToDee.linearize\nSeeToDee.initialize","category":"page"},{"location":"api/#SeeToDee.linearize","page":"API","title":"SeeToDee.linearize","text":"A,B = linearize(f, x0, u0, p, t)\n\nLinearize dynamics function f w.r.t., state x, input u. Returns Jacobians A,B in\n\nx = A Δx + B Δu\n\nWorks for both continuous and discrete-time dynamics.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeeToDee.initialize","page":"API","title":"SeeToDee.initialize","text":"initialize(integ, x0, p, t = 0.0; solver=integ.solver, abstol=integ.abstol)\n\nGiven the differential state variables in x0, initialize the algebraic variables by solving the nonlinear problem f(x,u,p,t) = 0 using the provided solver.\n\nArguments:\n\ninteg: An intergrator like SimpleColloc\nx0: Initial state descriptor (differential and algebraic variables, where the algebraic variables comes last)\n\n\n\n\n\n","category":"function"},{"location":"#SeeToDee","page":"Home","title":"SeeToDee","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SeeToDee implements low-overhead, nonlinear variants of the classical c2d function from ControlSystems.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given a continuous-time dynamics function","category":"page"},{"location":"","page":"Home","title":"Home","text":"dot x = f(x u p t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"this package contains integrators that convert the continuous-time dynamics into a discrete-time dynamics function","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_t+Ts = f(x_t u_t p t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"that advances the state from time t to time t+T_s, with a Zero-order-Hold (ZoH) assumption on the input u.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The integrators in this package focus on","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inputs are first class, i.e., the signature of the dynamics take input signals (such as control signals or disturbance inputs) as arguments. This is in contrast to the DifferentialEquations ecosystem, where there are several different ways of handling inputs, none of which are quite first class.\nLow overhead for single-step integration, i.e., no solution handling, no interpolation, nothing fancy at all.\nFixed time step. All integrators are non-adaptive, i.e., the integrators do not change their step size using error control. This typically makes the integrator have a more predictable runtime. It also reduces overhead without affecting accuracy in situations when the fixed step-size is small in relation to what would be required to meet the desired accuracy, a situation which is uncommon when simulating control systems.\nDirt-simple interface, i.e., you literally use the integrator as a function x⁺ = f(x, u, p, t) that you can call in a loop etc. to perform simulations.\nMost things are manual. Want to simulate a trajectory? Write a loop!","category":"page"},{"location":"#Available-discretization-methods","page":"Home","title":"Available discretization methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following methods are available","category":"page"},{"location":"","page":"Home","title":"Home","text":"SeeToDee.Rk4 An explicit 4th order Runge-Kutta integrator with ZoH input. Supports non-stiff differential equations only. If called with StaticArrays, this method is allocation free.\nSeeToDee.SimpleColloc A textbook implementation of a direct collocation method (includes trapezoidal integration as a special case) with ZoH input. Supports stiff differential-algebraic equations (DAE) and fully implicit form 0 = F(x x u p t).","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The example below defines a dynamics function cartpole and then discretizes this using SeeToDee.Rk4 and propagates the state forward one time step","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SeeToDee, NonlinearSolve, StaticArrays\n\nfunction cartpole(x, u, p, t)\n    T = promote_type(eltype(x), eltype(u))\n    mc, mp, l, g = p\n\n    q  = x[SA[1, 2]]\n    qd = x[SA[3, 4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]\n    G = @SVector [0, mp * g * l * s]\n    B = @SVector [1, 0]\n    qdd = -H \\ (C * qd + G - B * u[1])\n    return [qd; qdd]\nend\n\nTs = 0.01\ndiscrete_dynamics_rk = SeeToDee.Rk4(cartpole, Ts; supersample=2)\n\nx0 = SA[1.0, 2.0, 3.0, 4.0]\nu0 = SA[1.0]\np = mc, mp, l, g = 1.0, 0.2, 0.5, 9.81\n\nx1_rk4 = discrete_dynamics_rk(x0, u0, p, 0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function discrete_dynamics_rk is now the discretized dynamics x^+ = f(x u p t), and x1_rk4 is the state at time 0+T_s. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, we do the same but with SeeToDee.SimpleColloc instead of SeeToDee.Rk4.","category":"page"},{"location":"","page":"Home","title":"Home","text":"n  = 5 # Number of collocation points\nnx = 4 # Number of differential state variables\nna = 0 # Number of algebraic variables\nnu = 1 # Number of inputs\nsolver = NonlinearSolve.NewtonRaphson()\n\ndiscrete_dynamics_colloc = SeeToDee.SimpleColloc(cartpole, Ts, nx, na, nu; n, abstol=1e-10, solver)\nx1_colloc = discrete_dynamics_colloc(x0, u0, p, 0)\n\nusing Test\n@test x1_rk4 ≈ x1_colloc atol=1e-2 # Test the it's roughly the same as the output of RK4","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we benchmark these two methods","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime $discrete_dynamics_rk($x0, $u0, $p, 0);     # 203.633 ns (0 allocations: 0 bytes)\n@btime $discrete_dynamics_colloc($x0, $u0, $p, 0); # 22.072 μs (80 allocations: 50.23 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"the explicit RK4 method is much faster in this case.","category":"page"},{"location":"#Using-fully-implicit-dynamics","page":"Home","title":"Using fully implicit dynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Below, we define the same dynamics as above, but this time in the fully implicit form","category":"page"},{"location":"","page":"Home","title":"Home","text":"0 = F(x x u p t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is occasionally useful in order to avoid inverting large coordinate-dependent mass matrices for mechanical systems etc. In the cartpole function, the mass matrix is called H, and it's of size 2×2","category":"page"},{"location":"","page":"Home","title":"Home","text":"function cartpole_implicit(dx, x, u, p, _=0)\n    T = promote_type(eltype(x), eltype(u))\n    mc, mp, l, g = 1.0, 0.2, 0.5, 9.81\n\n    q  = x[SA[1, 2]]\n    qd = x[SA[3, 4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]\n    G = @SVector [0, mp * g * l * s]\n    B = @SVector [1, 0]\n    Hqdd = (C * qd + G - B * u[1]) # Acceleration times mass matrix H\n    return [qd; -Hqdd] - [dx[SA[1, 2]]; H*dx[SA[3, 4]]] # We multiply H here instead of inverting H like above\nend\n\ndiscrete_dynamics_implicit = SimpleColloc(cartpole_implicit, Ts, nx, na, nu; n, abstol=1e-10, residual=true, solver)\n\nx1_implicit = discrete_dynamics_implicit(x0, u0, p, 0)\n\n@test x1_implicit ≈ x1_colloc atol=1e-9","category":"page"},{"location":"","page":"Home","title":"Home","text":"@btime $discrete_dynamics_implicit($x0, $u0, 0, 0); # 21.911 μs (84 allocations: 50.39 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this system, the solve time is almost identical to the explicit collocation case, but for larger systems, the implicit form can be faster.","category":"page"},{"location":"#Simulate-whole-trajectories","page":"Home","title":"Simulate whole trajectories","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulation is done by implementing the loop manually, for example (pseudocode)","category":"page"},{"location":"","page":"Home","title":"Home","text":"discrete_dynamics = SeeToDee.Rk4(cartpole, Ts; supersample=2)\n\nx = x0\nX = [x]\nU = []\nfor i = 1:T\n    u = compute_control_input(x)      # State feedback, MPC, etc.\n    x = discrete_dynamics(x, u, p, t) # Propagate state forward one step\n    push!(X, x) # Log data\n    push!(U, u)\nend","category":"page"}]
}
